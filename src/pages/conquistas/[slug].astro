---
import BaseLayout from "../../layouts/BaseLayout.astro";
import conquistas from "../../data/conquistas";

export function getStaticPaths() {
  return conquistas.map(c => ({
    params: { slug: c.slug },
    props: { conquista: c },
  }));
}

const { conquista } = Astro.props;

// Agora lat e lng são campos separados
const lat = parseFloat(conquista.lat);
const lng = parseFloat(conquista.lng);

// Pontos de origem e destino (source e target)
const sourceLat = conquista.latSource ? parseFloat(conquista.latSource) : null;
const sourceLng = conquista.lngSource ? parseFloat(conquista.lngSource) : null;
const targetLat = conquista.latTarget ? parseFloat(conquista.latTarget) : null;
const targetLng = conquista.lngTarget ? parseFloat(conquista.lngTarget) : null;
---

<BaseLayout>
  <section class="px-6 md:px-20 py-6 max-w-9xl flex flex-col md:flex-row items-center gap-8">

    {conquista.image && (
      <img
        src={conquista.image}
        alt={conquista.name}
        class="w-24 h-24 min-w-0 min-h-0 max-w-24 max-h-24 object-contain rounded-lg shrink-0 bg-neutral-900"
        style="aspect-ratio: 1 / 1;"
      />
    )} 
    <div class="flex-1">
      <div class="flex-1">
        <div class="flex items-center justify-between">
        <h1 class="text-4xl font-serif mb-2">{conquista.shortName} - {conquista.name}</h1>
        <a
          href="/conquistas"
          class="flex items-center gap-2 border border-neutral-700 px-4 py-2 rounded-full hover:border-neutral-400 hover:text-white transition text-base" 
        >
          <span class="hidden md:inline">← Voltar para conquistas</span>
        </a>
      </div>
        <p class="text-neutral-400">
          {conquista.cityTarget ? "Origem" : "Localização"}: {conquista.city} · {conquista.state}, {conquista.country}
        </p> 
      </div>
      <div class="flex-1">
        {conquista.cityTarget && (
          <p class="text-neutral-400">
            Destino: {conquista.cityTarget} · {conquista.stateTarget}
          </p>
        )}
        {conquista.length_m > 0 && !isNaN(Number(conquista.length_m)) && (
          <p class="text-neutral-400">
            Comprimento: {Number(conquista.length_m) } m
          </p>
        )}
     
        {conquista.note && (
          <p class="text-neutral-400">
            {conquista.note}
          </p>
        )}
      </div>
    </div>
  </section>
  <!-- MAPA abaixo dos campos -->
  <section class="px-6 md:px-20 pb-6 max-w-9xl">
    <div
      id="map"
      class="w-full h-105 rounded-2xl overflow-hidden border border-neutral-800"
      style="min-height:420px;"
      data-lat={lat}
      data-lng={lng}
      data-title={conquista.name}
      data-source-lat={sourceLat}
      data-source-lng={sourceLng}
      data-target-lat={targetLat}
      data-target-lng={targetLng}
    ></div>
  </section>
</BaseLayout>

<!-- Google Maps API -->
<script
  src={`https://maps.googleapis.com/maps/api/js?key=${import.meta.env.PUBLIC_GOOGLE_MAPS_API_KEY}&callback=initMap`}
  async
  defer
></script>

<script is:inline>
  window.initMap = function () {
    const mapEl = document.getElementById("map");
    if (!mapEl) return;

    const lat       = mapEl.dataset.lat ? parseFloat(mapEl.dataset.lat) : null;
    const lng       = mapEl.dataset.lng ? parseFloat(mapEl.dataset.lng) : null;
    const sourceLat = mapEl.dataset.sourceLat ? parseFloat(mapEl.dataset.sourceLat) : null;
    const sourceLng = mapEl.dataset.sourceLng ? parseFloat(mapEl.dataset.sourceLng) : null;
    const targetLat = mapEl.dataset.targetLat ? parseFloat(mapEl.dataset.targetLat) : null;
    const targetLng = mapEl.dataset.targetLng ? parseFloat(mapEl.dataset.targetLng) : null;
    const title     = mapEl.dataset.title;

    // Define pontos válidos para ajustar o bounds
    const points = [
      (lat && lng) ? { lat, lng } : null,
      ...(sourceLat && sourceLng ? [{ lat: sourceLat, lng: sourceLng }] : []),
      ...(targetLat && targetLng ? [{ lat: targetLat, lng: targetLng }] : [])
    ].filter(Boolean);

    const map = new google.maps.Map(mapEl, {
      center: points[0] || { lat: 0, lng: 0 },
      zoom: 8,
      mapTypeId: "roadmap",
      streetViewControl: false,
      fullscreenControl: false,
    });

    // Ajusta o bounds se houver mais de um ponto
    if (points.length > 1) {
      const bounds = new google.maps.LatLngBounds();
      points.forEach(p => bounds.extend(p));
      map.fitBounds(bounds);
    }

    // Marcador principal
    if (lat && lng) {
      new google.maps.Marker({
        position: { lat, lng },
        map,
        title,
        label: "P",
      });
    }

    // Marcador de origem
    if (sourceLat && sourceLng) {
      new google.maps.Marker({
        position: { lat: sourceLat, lng: sourceLng },
        map,
        title: "Origem",
        icon: {
          url: "/src/assets/source-marker.png",
          scaledSize: new google.maps.Size(32, 32),
        },
      });
    }

    // Marcador de destino
    if (targetLat && targetLng) {
      new google.maps.Marker({
        position: { lat: targetLat, lng: targetLng },
        map,
        title: "Destino",
        icon: {
          url: "/src/assets/target-marker.png",
          scaledSize: new google.maps.Size(32, 32),
        },
      });
    }

    // Traçar rota se origem e destino existirem
    if (sourceLat && sourceLng && targetLat && targetLng) {
      const directionsService = new google.maps.DirectionsService();
      const directionsRenderer = new google.maps.DirectionsRenderer({
        map,
        suppressMarkers: true,
        polylineOptions: { strokeColor: "#d00", strokeWeight: 4 }
      });

      const waypoints = [];
      if (lat && lng) {
        waypoints.push({
          location: { lat, lng },
          stopover: true,
        });
      }

      directionsService.route(
        {
          origin: { lat: sourceLat, lng: sourceLng },
          destination: { lat: targetLat, lng: targetLng },
          waypoints,
          travelMode: google.maps.TravelMode.DRIVING,
        },
        (result, status) => {
          if (status === "OK") {
            directionsRenderer.setDirections(result);
          } else {
            // fallback: desenha linha simples
            const routePoints = [
              { lat: sourceLat, lng: sourceLng },
              ...(lat && lng ? [{ lat, lng }] : []),
              { lat: targetLat, lng: targetLng }
            ];
            new google.maps.Polyline({
              path: routePoints,
              map,
              strokeColor: "#0a0",
              strokeOpacity: 0.7,
              strokeWeight: 4,
              icons: [{
                icon: { path: "M 0,-1 0,1", strokeOpacity: 1, scale: 4 },
                offset: "0",
                repeat: "20px"
              }]
            });
          }
        }
      );
    }
  };
</script>